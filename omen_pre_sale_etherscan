import time
import requests
import pandas as pd
from typing import Optional, Tuple

# =========================
# AYARLAR (BURAYI DOLDUR)
# =========================
ETHERSCAN_API_KEY = "CK1HX11UVHPNJ2VSYS5FNEX3YRDHKRV1EK"

CHAIN_ID = 1  # Ethereum mainnet (Etherscan v2 multichain)  [oai_citation:3‡Etherscan](https://docs.etherscan.io/v2-migration?utm_source=chatgpt.com)
BASE_URL = "https://api.etherscan.io/v2/api"  #  [oai_citation:4‡Etherscan](https://docs.etherscan.io/v2-migration?utm_source=chatgpt.com)

PRESALE_CONTRACT = "0x10Cd25B8fA6f97356C82aAb8da039C3D7eF18401".lower()
EVENT_TOPIC0 = "0x95cfdb8b2e91654ec715d9403064639685780d9bc570c4c0732886c210481b9f".lower()

WALLET_FILE = "data_check.txt"

# =========================
# DECODE AYARLARI (ROBUST)
# =========================
# Presale şartına göre beklenen aralık (USD cinsinden)
EXPECTED_USD_MIN = 1
EXPECTED_USD_MAX = 100_000

# Eğer senin presale aralığın kesinse (500-25000 gibi) bunları daha dar yapabilirsin:
STRICT_USD_MIN = 400
STRICT_USD_MAX = 30_000

# Lock ayı beklenen aralık
LOCK_MONTHS_MIN = 0
LOCK_MONTHS_MAX = 12

# Etherscan log 'data' içinde hangi slotta ne var değişebildiği için:
# - USD miktarını (6 veya 18 decimals) data slotları içinde otomatik bulacağız
# - Lock ayını da 0..12 aralığındaki slotlardan otomatik bulacağız

# Not: Yine de istersen override edebilmen için aşağıdaki manuel değerler kalsın.
# None bırakılırsa otomatik seçer.
MANUAL_USD_SLOT = None        # ör: 0
MANUAL_USD_DECIMALS = None    # ör: 6
MANUAL_LOCK_SLOT = None       # ör: 2

# Çekme stratejisi:
PAGE_SIZE = 1000          # Etherscan offset limit  [oai_citation:5‡Etherscan](https://docs.etherscan.io/api-reference/endpoint/getlogs?utm_source=chatgpt.com)
SLEEP_BETWEEN_CALLS = 0.2  # rate limit’e saygı (gerekirse artır)  [oai_citation:6‡Etherscan](https://docs.etherscan.io/resources/rate-limits?utm_source=chatgpt.com)

# Eğer "result window is too large" gelirse block-range’i küçülterek parça parça çeker:
FROM_BLOCK = 0
TO_BLOCK = "latest"       # docs: toBlock "latest" kullanılabiliyor  [oai_citation:7‡Etherscan](https://docs.etherscan.io/api-reference/endpoint/getlogs-topics?utm_source=chatgpt.com)
INITIAL_BLOCK_STEP = 200_000  # büyükse küçült (50_000 gibi)

# =========================
# YARDIMCI FONKSİYONLAR
# =========================
def load_wallets(path: str) -> set[str]:
    s = set()
    with open(path, "r", encoding="utf-8") as f:
        for line in f:
            w = line.strip().lower()
            if w:
                s.add(w)
    return s

def topic_to_addr(topic_hex: str) -> str:
    # topic 32 byte, son 20 byte address
    return "0x" + topic_hex[-40:].lower()

def split_32byte_words(data_hex: str) -> list[int]:
    h = data_hex[2:] if data_hex.startswith("0x") else data_hex
    # 64 hex = 32 bytes
    if len(h) % 64 != 0:
        h = h.rjust((len(h) + 63) // 64 * 64, "0")
    return [int(h[i:i+64], 16) for i in range(0, len(h), 64)]

def _choose_usd_amount(words: list[int]) -> Tuple[Optional[float], Optional[int], Optional[int]]:
    """Return (usd_amount, slot_index, decimals) using heuristics."""
    if not words:
        return None, None, None

    # Manual override
    if MANUAL_USD_SLOT is not None and MANUAL_USD_DECIMALS is not None:
        i = int(MANUAL_USD_SLOT)
        d = int(MANUAL_USD_DECIMALS)
        if 0 <= i < len(words):
            return words[i] / (10 ** d), i, d

    candidates = []

    # First try strict range matches (prefer 6 decimals)
    for i in range(min(len(words), 8)):
        v = words[i]
        for d in (6, 18):
            amt = v / (10 ** d)
            if STRICT_USD_MIN <= amt <= STRICT_USD_MAX:
                candidates.append((0 if d == 6 else 1, amt, i, d))

    if candidates:
        candidates.sort(key=lambda x: (x[0], x[2]))
        _, amt, i, d = candidates[0]
        return float(amt), int(i), int(d)

    # Fallback: broader range matches
    for i in range(min(len(words), 8)):
        v = words[i]
        for d in (6, 18):
            amt = v / (10 ** d)
            if EXPECTED_USD_MIN <= amt <= EXPECTED_USD_MAX:
                # Prefer values with 2 decimal-like shape (not mandatory)
                frac = abs(amt - round(amt, 2))
                score = 0
                if d == 6:
                    score -= 2
                if frac < 1e-9:
                    score -= 1
                candidates.append((score, amt, i, d))

    if candidates:
        candidates.sort(key=lambda x: (x[0], x[2]))
        score, amt, i, d = candidates[0]
        return float(amt), int(i), int(d)

    return None, None, None


def _choose_lock_months(words: list[int]) -> Tuple[Optional[int], Optional[int]]:
    """Return (lock_months, slot_index) using heuristics."""
    if not words:
        return None, None

    # Manual override
    if MANUAL_LOCK_SLOT is not None:
        i = int(MANUAL_LOCK_SLOT)
        if 0 <= i < len(words):
            return int(words[i]), i

    candidates = []
    for i in range(min(len(words), 8)):
        v = words[i]
        if LOCK_MONTHS_MIN <= v <= LOCK_MONTHS_MAX:
            # Prefer values >1 (avoid picking flags like 0/1 if there is a better month)
            penalty = 1 if v in (0, 1) else 0
            candidates.append((penalty, i, int(v)))

    if not candidates:
        return None, None

    candidates.sort(key=lambda x: (x[0], x[1]))
    penalty, i, v = candidates[0]
    return int(v), int(i)


def _fmt_usd(x: float) -> str:
    try:
        return f"{x:,.2f}"
    except Exception:
        return str(x)

def etherscan_call(params: dict) -> dict:
    r = requests.get(BASE_URL, params=params, timeout=60)
    r.raise_for_status()
    return r.json()

def get_latest_block() -> int:
    # proxy/eth_blockNumber endpoint (v2)  [oai_citation:8‡Etherscan](https://docs.etherscan.io/api-reference/endpoint/ethblocknumber?utm_source=chatgpt.com)
    params = {
        "chainid": CHAIN_ID,
        "module": "proxy",
        "action": "eth_blockNumber",
        "apikey": ETHERSCAN_API_KEY,
    }
    js = etherscan_call(params)
    # response: {"jsonrpc":"2.0","result":"0x....",...}
    return int(js["result"], 16)

def fetch_logs_range(from_block, to_block) -> list[dict]:
    """Tek bir block aralığı için, pagination ile tüm logları çeker."""
    all_logs = []
    page = 1

    while True:
        params = {
            "chainid": CHAIN_ID,
            "module": "logs",
            "action": "getLogs",
            "address": PRESALE_CONTRACT,
            "fromBlock": from_block,
            "toBlock": to_block,
            "topic0": EVENT_TOPIC0,
            "page": page,
            "offset": PAGE_SIZE,  # max 1000  [oai_citation:9‡Etherscan](https://docs.etherscan.io/api-reference/endpoint/getlogs?utm_source=chatgpt.com)
            "apikey": ETHERSCAN_API_KEY,
        }
        js = etherscan_call(params)

        status = js.get("status")
        result = js.get("result")

        # Etherscan bazen result'u string hata olarak döndürebiliyor
        if isinstance(result, str):
            msg = result.lower()

            # rate limit
            if "rate limit" in msg or "max rate limit" in msg:
                time.sleep(1.2)
                continue

            # window too large
            if "result window is too large" in msg or "window" in msg:
                raise RuntimeError("WINDOW_TOO_LARGE")

            # başka hata
            raise RuntimeError(f"Etherscan error: {result}")

        # no logs
        if status != "1" or not result:
            break

        all_logs.extend(result)
        page += 1
        time.sleep(SLEEP_BETWEEN_CALLS)

    return all_logs

def fetch_all_logs_safely(from_block: int, to_block):
    """Geniş aralığı, gerekirse block-step ile parça parça çek."""
    if to_block == "latest":
        latest = get_latest_block()
    else:
        latest = int(to_block)

    step = INITIAL_BLOCK_STEP
    cur = int(from_block)
    all_logs = []

    while cur <= latest:
        end = min(cur + step - 1, latest)

        try:
            logs = fetch_logs_range(cur, end)
            all_logs.extend(logs)
            cur = end + 1
        except RuntimeError as e:
            if str(e) == "WINDOW_TOO_LARGE":
                # aralık büyük → küçült
                step = max(5_000, step // 2)
                print(f"[WARN] Window too large. Reducing block step to {step} and retrying...")
                continue
            raise

    return all_logs

def parse_logs(logs: list[dict]) -> pd.DataFrame:
    rows = []
    for lg in logs:
        topics = lg.get("topics", [])
        if len(topics) < 2:
            continue

        wallet = topic_to_addr(topics[1])
        words = split_32byte_words(lg.get("data", "0x"))
        if not words:
            continue

        usd_amount, usd_slot, usd_decimals = _choose_usd_amount(words)
        lock_months, lock_slot = _choose_lock_months(words)

        # Eğer ikisi de bulunamazsa atla
        if usd_amount is None or lock_months is None:
            continue

        rows.append({
            "tx_hash": lg.get("transactionHash"),
            "blockNumber": int(lg.get("blockNumber", "0x0"), 16),
            "timestamp": int(lg.get("timeStamp", "0x0"), 16),
            "wallet": wallet,
            "usd_amount": float(usd_amount),
            "lock_months": int(lock_months),
            "usd_slot": usd_slot,
            "usd_decimals": usd_decimals,
            "lock_slot": lock_slot,
        })

    df = pd.DataFrame(rows)
    if not df.empty:
        df = df.sort_values(["blockNumber"]).reset_index(drop=True)
    return df

# =========================
# MAIN
# =========================
def main():
    if not ETHERSCAN_API_KEY or ETHERSCAN_API_KEY == "PUT_YOUR_KEY_HERE":
        raise SystemExit("ETHERSCAN_API_KEY ayarla (dosyanın en üstünde).")

    our_wallets = load_wallets(WALLET_FILE)
    print(f"[INFO] data_check.txt wallets: {len(our_wallets)}")

    print("[INFO] Fetching logs...")
    logs = fetch_all_logs_safely(FROM_BLOCK, TO_BLOCK)
    print(f"[INFO] Logs fetched: {len(logs)}")

    df = parse_logs(logs)
    print(f"[INFO] Parsed events: {len(df)}")

    if df.empty:
        print("[WARN] Hiç event parse edilemedi. Topic0/contract doğru mu kontrol et.")
        return

    df["in_our_list"] = df["wallet"].isin(our_wallets)

    # =========================
    # TARİH FİLTRESİ (21 Aralık 2025 20:25 UTC+3)
    # =========================
    # 21 Dec 2025 20:25 (TR / UTC+3) -> UTC timestamp
    CUTOFF_TS = 1766323500  # 2025-12-21 17:25:00 UTC

    df_after_cutoff = df[df["timestamp"] >= CUTOFF_TS].copy()

    after_unique_total = df_after_cutoff["wallet"].nunique()
    after_unique_in = df_after_cutoff.loc[df_after_cutoff["in_our_list"], "wallet"].nunique()
    after_unique_out = df_after_cutoff.loc[~df_after_cutoff["in_our_list"], "wallet"].nunique()

    after_usd_total = float(df_after_cutoff["usd_amount"].sum())
    after_usd_in = float(df_after_cutoff.loc[df_after_cutoff["in_our_list"], "usd_amount"].sum())
    after_usd_out = float(df_after_cutoff.loc[~df_after_cutoff["in_our_list"], "usd_amount"].sum())

    # =========================
    # TEMİZ ÖZET + DETAYLAR
    # =========================
    total_events = len(df)
    total_unique = df["wallet"].nunique()

    in_unique = df.loc[df["in_our_list"], "wallet"].nunique()
    out_unique = df.loc[~df["in_our_list"], "wallet"].nunique()

    total_usd = float(df["usd_amount"].sum())
    in_usd = float(df.loc[df["in_our_list"], "usd_amount"].sum())
    out_usd = float(df.loc[~df["in_our_list"], "usd_amount"].sum())

    print("\n================= GENEL ÖZET =================")
    print(f"Toplam event:                 {total_events}")
    print(f"Toplam unique wallet:         {total_unique}")
    print(f"Bizde OLAN unique wallet:     {in_unique}")
    print(f"Bizde OLMAYAN unique wallet:  {out_unique}")
    print(f"Toplam yatırılan (USD):       {_fmt_usd(total_usd)}")
    print(f"Bizim listemiz (USD):         {_fmt_usd(in_usd)}")
    print(f"Bizim DIŞIMIZ (USD):          {_fmt_usd(out_usd)}")

    print("\n================= 21 ARALIK 2025 20:25 SONRASI =================")
    print(f"Unique wallet (toplam):       {after_unique_total}")
    print(f"Bizde OLAN wallet:            {after_unique_in}")
    print(f"Bizde OLMAYAN wallet:         {after_unique_out}")
    print(f"Toplam yatırılan (USD):       {_fmt_usd(after_usd_total)}")
    print(f"Bizim listemiz (USD):         {_fmt_usd(after_usd_in)}")
    print(f"Bizim DIŞIMIZ (USD):          {_fmt_usd(after_usd_out)}")

    # Lockup dağılımı (genel)
    lockup_all = (df.groupby(["lock_months"], as_index=False)
                    .agg(events=("tx_hash", "count"), total_usd=("usd_amount", "sum"))
                    .sort_values("lock_months"))

    lockup_split = (df.groupby(["lock_months", "in_our_list"], as_index=False)
                      .agg(events=("tx_hash", "count"), total_usd=("usd_amount", "sum"))
                      .sort_values(["lock_months", "in_our_list"]))

    print("\n================= TÜM LOCKUPLAR (GENEL) =================")
    if lockup_all.empty:
        print("(boş)")
    else:
        print(lockup_all.to_string(index=False, formatters={"total_usd": _fmt_usd}))

    print("\n================= TÜM LOCKUPLAR (BİZDE VAR/YOK) =================")
    if lockup_split.empty:
        print("(boş)")
    else:
        tmp = lockup_split.copy()
        tmp["group"] = tmp["in_our_list"].map({True: "BIZDE_VAR", False: "BIZDE_YOK"})
        tmp = tmp.drop(columns=["in_our_list"]).rename(columns={"group": "group"})
        print(tmp.to_string(index=False, formatters={"total_usd": _fmt_usd}))

    # Wallet + lockup bazında temiz tablo
    wl = (df.groupby(["wallet", "in_our_list", "lock_months"], as_index=False)
            .agg(events=("tx_hash", "count"), total_usd=("usd_amount", "sum"))
            .sort_values(["in_our_list", "total_usd"], ascending=[False, False]))

    # Bizde OLAN
    wl_in = wl[wl["in_our_list"] == True].copy()
    wl_in["group"] = "BIZDE_VAR"
    wl_in = wl_in.drop(columns=["in_our_list"]).sort_values(["total_usd"], ascending=False)

    print("\n================= BİZDE OLAN CÜZDANLAR (WALLET + AY + USD) =================")
    if wl_in.empty:
        print("(boş)")
    else:
        print(wl_in.to_string(index=False, formatters={"total_usd": _fmt_usd}))

    # Bizde OLMAYAN
    wl_out = wl[wl["in_our_list"] == False].copy()
    wl_out["group"] = "BIZDE_YOK"
    wl_out = wl_out.drop(columns=["in_our_list"]).sort_values(["total_usd"], ascending=False)

    print("\n================= BİZDE OLMAYAN CÜZDANLAR (WALLET + AY + USD) =================")
    if wl_out.empty:
        print("(boş)")
    else:
        print(wl_out.to_string(index=False, formatters={"total_usd": _fmt_usd}))

    # Ayrıca wallet bazında toplamlar (senin istediğin 'biz toplam kaç dolar yatırdık' burada zaten var)
    wallet_totals = (df.groupby(["wallet", "in_our_list"], as_index=False)
                       .agg(events=("tx_hash", "count"), total_usd=("usd_amount", "sum"))
                       .sort_values("total_usd", ascending=False))

    # Dosyalar
    df.to_csv("presale_events.csv", index=False)
    lockup_all.to_csv("presale_lockups_all.csv", index=False)
    lockup_split.to_csv("presale_lockups_split.csv", index=False)
    wl_in.to_csv("presale_wallet_lockups_in.csv", index=False)
    wl_out.to_csv("presale_wallet_lockups_out.csv", index=False)
    wallet_totals.to_csv("presale_wallet_totals.csv", index=False)
    df_after_cutoff.to_csv("presale_events_after_2025_12_21_2025.csv", index=False)

    unknown_wallets = sorted(set(df.loc[~df["in_our_list"], "wallet"].unique()))
    with open("wallets_not_in_data_check.txt", "w", encoding="utf-8") as f:
        f.write("\n".join(unknown_wallets))

    print("\n[OK] Wrote files:")
    print(" - presale_events.csv  (event bazlı ham ama temizlenmiş)")
    print(" - presale_lockups_all.csv")
    print(" - presale_lockups_split.csv")
    print(" - presale_wallet_lockups_in.csv")
    print(" - presale_wallet_lockups_out.csv")
    print(" - presale_wallet_totals.csv")
    print(" - wallets_not_in_data_check.txt")

    # Decode debug: hangi slot/decimals seçilmiş görmek istersen
    debug = (df.groupby(["usd_slot", "usd_decimals"], as_index=False)
               .size()
               .sort_values("size", ascending=False))
    print("\n[DEBUG] USD decode seçimleri (slot/decimals -> kaç event):")
    print(debug.to_string(index=False))

if __name__ == "__main__":
    main()